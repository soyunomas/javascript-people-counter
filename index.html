<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contador de Personas</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <!-- Optional: Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <!-- HLS.js library -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        body { background-color: #f8f9fa; padding-bottom: 1rem; }
        #webcam { /* Sigue oculto */ }
        #canvas-container { position: relative; width: 100%; margin-bottom: 0.5rem; border: 2px solid #0d6efd; background-color: #fff; overflow: hidden; aspect-ratio: 4 / 3; display: flex; align-items: center; justify-content: center; }
        #canvas { display: block; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); -webkit-transform: scaleX(-1); }
        #hiddenCanvas { display: none; }
        #loading-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; background-color: rgba(255, 255, 255, 0.85); padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #loading-indicator .spinner-border { width: 3rem; height: 3rem; }
        #loading-status-text { margin-top: 0.8rem; font-weight: 500; color: #495057; }
        #direction-indicator { font-size: 0.9em; color: #6c757d; }
        #status { min-height: 1.2em; font-size: 0.85em; }
        #invert-button.active { background-color: #198754; border-color: #198754; }
        #pause-button.paused { background-color: #ffc107; border-color: #ffc107; color: black; }
        @keyframes flash { 0% { background-color: #d1e7dd; } 100% { background-color: transparent; } }
        .flash-success { animation: flash 0.5s ease-out; }
        .form-range { cursor: pointer; }
        .popover-trigger { cursor: help; }
        .input-group-text { min-width: 55px; justify-content: center; font-size: 0.8em; }
        .right-panel { max-height: 90vh; overflow-y: auto; padding: 1rem; }
        .right-panel .alert { font-size: 1.5rem; padding: 0.6rem; }
        .right-panel .alert .fw-bold { font-size: 1.5rem; }
        .right-panel .btn-sm { padding: 0.2rem 0.5rem; font-size: 0.8rem;}
        .right-panel .h6 { font-size: 1rem; }
        .right-panel .form-check-label { font-size: 0.85em;}
        .right-panel .small, .right-panel .form-label { font-size: 0.85em;}
        #status.error { color: #dc3545; font-weight: bold; }
        #status.warning { color: #ffc107; }
        #ws-status-indicator { font-size: 0.75em; margin-left: 10px; }
        #ws-status-indicator .badge { padding: 0.2em 0.4em; }
        .right-panel .accordion { margin-bottom: 1rem; }
        .right-panel .accordion-button { font-size: 0.9rem; padding: 0.75rem 1rem; }
        .right-panel .accordion-body { padding: 1rem; font-size: 0.9rem; }
        .right-panel .accordion-body .form-label { margin-bottom: 0.2rem; }
        .right-panel .accordion-body .btn { margin-top: 0.5rem; }
        .right-panel .accordion-body label.col-form-label-sm { font-size: 0.9em; }
        .right-panel .accordion-body .input-group-text { min-width: 55px; justify-content: center; font-size: 0.8em; }
        #hlsUrlContainer { display: none; }
    </style>
</head>
<body class="pt-3">

    <div class="container-fluid">
         <h1 class="mb-3 h3 text-center">Contador de Personas</h1>
        <div class="row g-3">
            <!-- Columna Izquierda: Canvas y Estado -->
            <div class="col-lg-6 col-md-6 d-flex flex-column align-items-center">
                 <video id="webcam" autoplay muted playsinline class="d-none"></video>
                 <div id="canvas-container">
                    <div id="loading-indicator" class="d-none">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Cargando...</span>
                        </div>
                        <p id="loading-status-text" class="mb-0">Inicializando...</p>
                    </div>
                    <canvas id="canvas"></canvas>
                 </div>
                 <canvas id="hiddenCanvas"></canvas>
                 <div class="text-center text-muted small w-100 mt-1 d-flex justify-content-center align-items-center">
                    <span id="status">Cargando aplicación...</span>
                    <span id="ws-status-indicator"></span>
                 </div>
            </div>

            <!-- Columna Derecha: Controles, Ajustes y Config WS -->
            <div class="col-lg-6 col-md-6">
                <div class="right-panel">
                    <!-- Sección Principal de Controles -->
                    <div id="controls" class="d-flex flex-column align-items-center gap-2 mb-3 w-100">
                        <div id="counter-display" class="alert alert-success text-center p-2 w-100 mb-1"> Entradas: <span id="entradas" class="fw-bold">0</span> | Salidas: <span id="salidas" class="fw-bold">0</span> </div>
                        <div id="direction-indicator" class="text-center w-100"> <span id="direction-primary" class="text-success fw-bold"></span> | <span id="direction-secondary" class="text-danger"></span> <small class="d-block text-muted">(Cruzando la línea roja)</small> </div>
                        <div id="line-slider-container" class="d-flex align-items-center gap-2 w-100 px-1"> <label for="line-position-slider" class="form-label mb-0 small">Pos. Línea:</label> <input type="range" class="form-range flex-grow-1" id="line-position-slider" min="5" max="95" value="50"> <span id="line-position-value" class="badge bg-secondary" style="min-width: 40px;">50%</span> </div>
                        <div class="form-check form-switch align-self-center my-1"> <input class="form-check-input" type="checkbox" role="switch" id="line-orientation-switch"> <label class="form-check-label" for="line-orientation-switch">Línea Horizontal</label> </div>
                        <div id="personas-dentro-display" class="alert alert-info text-center p-2 w-100 mb-2"> Personas Dentro: <span id="personas-dentro" class="fw-bold">0</span> </div>
                        <div class="d-flex gap-2 justify-content-center flex-wrap w-100"> <button id="reset-button" class="btn btn-danger btn-sm">Resetear</button> <button id="invert-button" class="btn btn-warning btn-sm">Invertir Sentido</button> <button id="pause-button" class="btn btn-secondary btn-sm" disabled> <i class="bi bi-pause-fill"></i> Pausar </button> </div>
                    </div>

                    <!-- Accordion Fuente de Vídeo -->
                     <div class="accordion w-100" id="videoSourceAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="videoSourceHeading">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#videoSourceCollapse" aria-expanded="false" aria-controls="videoSourceCollapse">
                                    <i class="bi bi-camera-video-fill me-2"></i> Fuente de Vídeo
                                </button>
                            </h2>
                            <div id="videoSourceCollapse" class="accordion-collapse collapse" aria-labelledby="videoSourceHeading" data-bs-parent="#videoSourceAccordion">
                                <div class="accordion-body">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="videoSource" id="sourceWebcam" value="webcam" checked>
                                        <label class="form-check-label" for="sourceWebcam"> Webcam </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="videoSource" id="sourceHLS" value="hls">
                                        <label class="form-check-label" for="sourceHLS"> Stream URL (HLS) </label>
                                    </div>
                                    <div class="mt-2" id="hlsUrlContainer">
                                        <label for="hlsUrlInput" class="form-label">URL del Stream HLS (.m3u8):</label>
                                        <input type="url" class="form-control form-control-sm" id="hlsUrlInput" placeholder="https://...">
                                    </div>
                                    <button type="button" class="btn btn-success btn-sm" id="setSourceButton">
                                        <i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Accordion Ajustes de Detección -->
                    <div class="accordion w-100" id="detectionSettingsAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="detectionSettingsHeading">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#detectionSettingsCollapse" aria-expanded="false" aria-controls="detectionSettingsCollapse">
                                    <i class="bi bi-sliders me-2"></i> Ajustes de Detección
                                </button>
                            </h2>
                            <div id="detectionSettingsCollapse" class="accordion-collapse collapse" aria-labelledby="detectionSettingsHeading" data-bs-parent="#detectionSettingsAccordion">
                                <div class="accordion-body">
                                    <h5 class="visually-hidden">Ajustes de Detección</h5>
                                    <div class="mb-3 row gx-2 align-items-center"> <label for="score-threshold-slider" class="col-sm-4 col-form-label col-form-label-sm">Confianza Mín.:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="score-threshold-slider" min="0.1" max="0.9" step="0.05" value="0.5"> <span class="input-group-text" id="score-threshold-value">50%</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Umbral de Confianza" data-bs-content="Ignora detecciones si la confianza es menor. Filtra detecciones dudosas."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                                    <div class="mb-3 row gx-2 align-items-center"> <label for="frame-skip-slider" class="col-sm-4 col-form-label col-form-label-sm">Procesar cada:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="frame-skip-slider" min="1" max="10" step="1" value="1"> <span class="input-group-text" id="frame-skip-value">1 fr.</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Salto de Frames" data-bs-content="Procesa sólo cada N frames. Reduce uso de CPU a costa de reactividad."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                                    <div class="mb-2 row gx-2 align-items-center"> <label for="cooldown-slider" class="col-sm-4 col-form-label col-form-label-sm">Cooldown Cruce:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="cooldown-slider" min="0" max="5000" step="250" value="1000"> <span class="input-group-text" id="cooldown-value">1000ms</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Cooldown de Cruce" data-bs-content="Tiempo mínimo (ms) antes de volver a contar a la misma persona. Evita conteo múltiple. 0 deshabilita."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Accordion Configuración WebSocket -->
                    <div class="accordion w-100" id="wsConfigAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="wsConfigHeading">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#wsConfigCollapse" aria-expanded="false" aria-controls="wsConfigCollapse">
                                    <i class="bi bi-gear-fill me-2"></i> Configuración Servidor WebSocket
                                </button>
                            </h2>
                            <div id="wsConfigCollapse" class="accordion-collapse collapse" aria-labelledby="wsConfigHeading" data-bs-parent="#wsConfigAccordion">
                                <div class="accordion-body">
                                    <div class="mb-2">
                                        <label for="wsServerInput" class="form-label">IP o Host del Servidor:</label>
                                        <input type="text" class="form-control form-control-sm" id="wsServerInput" placeholder="Ej: 127.0.0.1 o servidor.dominio.com" value="127.0.0.1">
                                    </div>
                                    <div class="mb-2">
                                        <label for="wsPortInput" class="form-label">Puerto:</label>
                                        <input type="number" class="form-control form-control-sm" id="wsPortInput" placeholder="Ej: 8181" value="8181">
                                    </div>
                                    <button type="button" class="btn btn-primary btn-sm" id="wsConnectButton">
                                        <i class="bi bi-plug-fill me-1"></i> Conectar al Servidor WS
                                    </button>
                                </div>
                            </div>
                        </div>
                     </div>

                </div> <!-- Fin .right-panel -->
            </div> <!-- Fin Columna Derecha -->
        </div> <!-- Fin .row -->
    </div> <!-- Fin .container-fluid -->

    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <!-- HLS.js ya está incluido en <head> -->

    <script>
        // --- DOM Elements ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const hiddenCanvasElement = document.getElementById('hiddenCanvas');
        const hiddenCanvasCtx = hiddenCanvasElement.getContext('2d');
        const statusElement = document.getElementById('status');
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingStatusText = document.getElementById('loading-status-text');
        const entradasElement = document.getElementById('entradas');
        const salidasElement = document.getElementById('salidas');
        const personasDentroElement = document.getElementById('personas-dentro');
        const resetButton = document.getElementById('reset-button');
        const invertButton = document.getElementById('invert-button');
        const pauseButton = document.getElementById('pause-button');
        const canvasContainer = document.getElementById('canvas-container');
        const lineSlider = document.getElementById('line-position-slider');
        const lineValueSpan = document.getElementById('line-position-value');
        const lineOrientationSwitch = document.getElementById('line-orientation-switch');
        const directionPrimarySpan = document.getElementById('direction-primary');
        const directionSecondarySpan = document.getElementById('direction-secondary');
        const scoreThresholdSlider = document.getElementById('score-threshold-slider');
        const scoreThresholdValueSpan = document.getElementById('score-threshold-value');
        const frameSkipSlider = document.getElementById('frame-skip-slider');
        const frameSkipValueSpan = document.getElementById('frame-skip-value');
        const cooldownSlider = document.getElementById('cooldown-slider');
        const cooldownValueSpan = document.getElementById('cooldown-value');
        const wsStatusIndicator = document.getElementById('ws-status-indicator');
        const wsServerInput = document.getElementById('wsServerInput');
        const wsPortInput = document.getElementById('wsPortInput');
        const wsConnectButton = document.getElementById('wsConnectButton');
        const sourceWebcamRadio = document.getElementById('sourceWebcam');
        const sourceHLSRadio = document.getElementById('sourceHLS');
        const hlsUrlContainer = document.getElementById('hlsUrlContainer');
        const hlsUrlInput = document.getElementById('hlsUrlInput');
        const setSourceButton = document.getElementById('setSourceButton');

        // --- State Variables ---
        let model = null; let lineaImaginariaX = null; let lineaImaginariaY = null; let isLineHorizontal = false; let animationFrameId = null; let isInverted = false; let isPaused = false; let frameCounter = 0;
        let isWebcamReady = false; let isModelReady = false; let isVideoPlaying = false; // Nuevo flag para saber si el video está activo
        let currentVideoSource = 'webcam';
        let hls = null;
        // --- Tracking State ---
        let trackedPersons = new Map(); let nextTrackId = 0; let entradas = 0; let salidas = 0;
        // --- Configurable Parameters ---
        let scoreThreshold = 0.5; let frameSkipCount = 1; let cooldownMillis = 1000;
        // --- Tracking Parameters ---
        const MAX_DISTANCE = 100; const MAX_MISSED_FRAMES = 10;
        // --- WebSocket State ---
        let websocket = null; let isWsConnected = false; let wsStatus = 'disconnected';

        // --- Loader Functions ---
        function showLoading(message) { loadingStatusText.textContent = message; loadingIndicator.classList.remove('d-none'); updateMainStatus(message); }
        function hideLoading() { loadingIndicator.classList.add('d-none'); }
        // --- Helper Functions ---
        function calculateCentroid(bbox) { return { x: bbox[0] + bbox[2] / 2, y: bbox[1] + bbox[3] / 2 }; }
        function calculateDistance(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
        function getSide(centroid) { const canvasCentroidX = canvasElement.width - centroid.x; if (isLineHorizontal) { if (lineaImaginariaY === null) return null; return centroid.y < lineaImaginariaY ? 'top' : 'bottom'; } else { if (lineaImaginariaX === null) return null; return canvasCentroidX < lineaImaginariaX ? 'left' : 'right'; } }
        function calculateLinePosition() { const sliderValue = parseInt(lineSlider.value); if (isLineHorizontal) { if(canvasElement.height > 0) { lineaImaginariaY = canvasElement.height - (sliderValue / 100) * canvasElement.height; lineaImaginariaX = null; } } else { if(canvasElement.width > 0) { lineaImaginariaX = canvasElement.width - (sliderValue / 100) * canvasElement.width; lineaImaginariaY = null; } } lineValueSpan.textContent = `${sliderValue}%`; }
        function updateMainStatus(message, type = 'info') { statusElement.textContent = message; statusElement.className = ''; if (type === 'error') statusElement.classList.add('error'); else if (type === 'warning') statusElement.classList.add('warning'); }
        function updateWebSocketStatusIndicator() { let badgeClass = 'bg-secondary'; let text = 'WS: Desconectado'; switch (wsStatus) { case 'connecting': badgeClass = 'bg-warning text-dark'; text = 'WS: Conectando...'; break; case 'connected': badgeClass = 'bg-success'; text = 'WS: Conectado'; break; case 'error': badgeClass = 'bg-danger'; text = 'WS: Error'; break; case 'disconnected': default: badgeClass = 'bg-secondary'; text = 'WS: Desconectado'; break; } wsStatusIndicator.innerHTML = `<span class="badge ${badgeClass}">${text}</span>`; }
        function updateStatus(message, type = 'info') { if (!isPaused) { updateMainStatus(message, type); } updateWebSocketStatusIndicator(); }
        function addSecureContextWarning(baseMessage) { return `${baseMessage} (Nota: Usar localhost/HTTPS es lo recomendado y más fiable.)`; }

        // --- Video Source Handling ---
        function cleanupVideoSource() {
            console.log("Limpiando fuente de vídeo actual...");
            isVideoPlaying = false; // Marcar como no activo
            if (videoElement.srcObject) { videoElement.srcObject.getTracks().forEach(track => track.stop()); videoElement.srcObject = null; console.log("Webcam detenida."); }
            if (hls) { hls.destroy(); hls = null; console.log("Instancia HLS destruida."); }
            videoElement.removeAttribute('src'); videoElement.load(); // Forzar recarga y limpieza de src
            isWebcamReady = false;
            if(canvasCtx) canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if(hiddenCanvasCtx) hiddenCanvasCtx.clearRect(0, 0, hiddenCanvasElement.width, hiddenCanvasElement.height);
        }

        async function setupWebcam() {
            cleanupVideoSource();
            showLoading('Solicitando acceso a la webcam...');
            isWebcamReady = false;
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { updateStatus(addSecureContextWarning('Error: API de Webcam no soportada.'), 'error'); hideLoading(); throw new Error('getUserMedia no soportado.'); }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                videoElement.srcObject = stream;
                videoElement.muted = true;
                currentVideoSource = 'webcam';
                // 'loadedmetadata' se encargará de isWebcamReady = true y checkIfReadyToDetect
                await videoElement.play(); // Intenta reproducir
                console.log("Webcam iniciada.");
                // No llamamos hideLoading aquí, esperamos a loadedmetadata/playing
            } catch (err) {
                 console.error("Error al acceder webcam:", err.name, err.message); let userMessage = 'Error al acceder a la webcam.'; if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = 'Permiso denegado para la webcam.'; else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = 'No se encontró cámara web.'; else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') userMessage = 'Cámara ocupada o error hardware.'; else if (err.name === 'SecurityError') userMessage = addSecureContextWarning('Error seguridad cámara.'); else userMessage = `Error desconocido (${err.name}).`; updateMainStatus(addSecureContextWarning(userMessage), 'error');
                 hideLoading(); // Ocultar si falla
                throw err;
            }
        }

        function setupHLS(url) {
            cleanupVideoSource();
            showLoading(`Cargando stream HLS: ${url.substring(0, 100)}...`); // Mostrar URL truncada
            console.log(`Intentando cargar HLS desde: ${url}`);
            currentVideoSource = 'hls';
            isWebcamReady = false;

            if (Hls.isSupported()) {
                console.log("hls.js es soportado. Creando instancia...");
                hls = new Hls({
                     // Opciones de configuración si fueran necesarias, ej:
                     // enableWorker: true,
                     // lowLatencyMode: true,
                });
                hls.loadSource(url);
                hls.attachMedia(videoElement);
                videoElement.muted = true;

                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    console.log("Manifiesto HLS parseado, intentando reproducir.");
                    videoElement.play().catch(e => {
                        console.error("Error al intentar reproducir HLS tras MANIFEST_PARSED:", e);
                        updateMainStatus('Error al reproducir stream HLS.', 'error');
                        hideLoading(); // Ocultar si falla play
                        setSourceButton.disabled = false;
                        setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente';
                    });
                });
                // 'loadedmetadata' y 'playing' se encargarán de ocultar el loading

                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('Error HLS:', data);
                    let errorMsg = 'Error desconocido en HLS.';
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR: errorMsg = `Error de red HLS (${data.details}). Verifica URL/CORS.`; if (data.details === 'manifestLoadError' || data.details === 'manifestParsingError') { errorMsg = `Error manifiesto HLS. ¿URL correcta?`; } break;
                            case Hls.ErrorTypes.MEDIA_ERROR: errorMsg = `Error de medio HLS (${data.details}).`; break;
                            default: errorMsg = `Error fatal HLS: ${data.type}`;
                        }
                        if(hls) hls.destroy(); hls = null; currentVideoSource = '';
                    } else { errorMsg = `Error HLS: ${data.type}`; }
                    updateMainStatus(errorMsg, 'error');
                    hideLoading(); // Ocultar si falla HLS
                    setSourceButton.disabled = false;
                    setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente';
                });

            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                console.log("hls.js no soportado, intentando HLS nativo.");
                videoElement.src = url;
                videoElement.muted = true;
                 videoElement.play().catch(e => {
                    console.error("Error al intentar reproducir HLS nativo:", e);
                    updateMainStatus('Error al reproducir stream HLS (nativo).', 'error');
                    hideLoading(); // Ocultar si falla
                    setSourceButton.disabled = false;
                    setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente';
                });
                 // 'loadedmetadata' y 'playing' se encargarán de ocultar el loading
            } else {
                const errorMsg = 'Error: Tu navegador no soporta HLS.'; console.error(errorMsg); updateMainStatus(errorMsg, 'error');
                hideLoading(); // Ocultar si no hay soporte
                setSourceButton.disabled = false;
                setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente';
            }
        }

        // --- WebSocket Functions --- (Sin cambios)
        function connectWebSocket() { const server = wsServerInput.value.trim(); const port = wsPortInput.value.trim(); if (!server || !port || isNaN(parseInt(port))) { updateMainStatus('Por favor, introduce IP/Host y Puerto válidos.', 'warning'); updateWebSocketStatusIndicator(); return; } const wsUrl = `ws://${server}:${port}`; if (websocket && websocket.readyState !== WebSocket.CLOSED) { console.log("Cerrando conexión WS existente..."); websocket.close(); } updateMainStatus(`Intentando conectar a WS: ${wsUrl}...`, 'info'); wsStatus = 'connecting'; updateWebSocketStatusIndicator(); wsConnectButton.disabled = true; wsConnectButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Conectando...'; console.log(`Intentando conectar a ${wsUrl}`); websocket = new WebSocket(wsUrl); websocket.onopen = (event) => { console.log("WebSocket Conectado!", event); isWsConnected = true; wsStatus = 'connected'; updateStatus(isPaused ? 'Pausado.' : 'Detectando...', 'info'); wsConnectButton.disabled = false; wsConnectButton.innerHTML = '<i class="bi bi-plug"></i> Desconectar WS'; wsConnectButton.classList.remove('btn-primary'); wsConnectButton.classList.add('btn-secondary'); if (isModelReady && isVideoPlaying) { pauseButton.disabled = false; } }; websocket.onclose = (event) => { console.log("WebSocket Desconectado:", event); isWsConnected = false; wsStatus = 'disconnected'; let reason = event.reason || `código ${event.code}`; updateStatus(`WS Desconectado (${reason}). Conéctate para enviar datos.`, 'warning'); wsConnectButton.disabled = false; wsConnectButton.innerHTML = '<i class="bi bi-plug-fill me-1"></i> Conectar al Servidor WS'; wsConnectButton.classList.remove('btn-secondary'); wsConnectButton.classList.add('btn-primary'); pauseButton.disabled = true; }; websocket.onerror = (error) => { console.error("Error en WebSocket:", error); isWsConnected = false; wsStatus = 'error'; updateStatus('Error conexión WS. Verifica datos y servidor.', 'error'); wsConnectButton.disabled = false; wsConnectButton.innerHTML = '<i class="bi bi-plug-fill me-1"></i> Conectar al Servidor WS'; wsConnectButton.classList.remove('btn-secondary'); wsConnectButton.classList.add('btn-primary'); pauseButton.disabled = true; }; websocket.onmessage = (event) => { console.log("Mensaje WS recibido:", event.data); }; }
        function sendCanvasSnapshotViaWebSocket(direction) { const websocketIsOpen = websocket && websocket.readyState === WebSocket.OPEN; if (!websocketIsOpen) { console.warn('Intento de envío WS fallido: WebSocket no está conectado.'); updateWebSocketStatusIndicator(); return; } if (!videoElement || videoElement.readyState < 3 || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) { console.error("Error al enviar: Elemento de video no listo o dimensiones 0."); return; } if (!hiddenCanvasElement || !hiddenCanvasCtx) { console.error("Error al enviar: Canvas oculto o contexto no disponible."); return; } if (direction !== 'IN' && direction !== 'OUT') { console.error(`Error al enviar: Dirección inválida '${direction}'.`); return; } console.log(`Capturando snapshot limpio para dirección '${direction}' y enviando vía WebSocket...`); try { if (hiddenCanvasElement.width !== videoElement.videoWidth || hiddenCanvasElement.height !== videoElement.videoHeight) { hiddenCanvasElement.width = videoElement.videoWidth; hiddenCanvasElement.height = videoElement.videoHeight; console.log(`Canvas oculto redimensionado a ${hiddenCanvasElement.width}x${hiddenCanvasElement.height}`); } hiddenCanvasCtx.clearRect(0, 0, hiddenCanvasElement.width, hiddenCanvasElement.height); hiddenCanvasCtx.save(); hiddenCanvasCtx.scale(-1, 1); hiddenCanvasCtx.drawImage(videoElement, -hiddenCanvasElement.width, 0, hiddenCanvasElement.width, hiddenCanvasElement.height); hiddenCanvasCtx.restore(); const base64Image = hiddenCanvasElement.toDataURL('image/jpeg', 0.8); if (base64Image && typeof base64Image === 'string' && base64Image.startsWith('data:image/jpeg;base64,')) { const payload = { direction: direction, imageData: base64Image }; const jsonPayload = JSON.stringify(payload); console.log(`Enviando payload JSON (Dirección: ${direction}, Longitud img: ${base64Image.length})`); try { websocket.send(jsonPayload); console.log("Payload JSON enviado al backend."); } catch (sendError) { console.error("Error DENTRO de websocket.send():", sendError); updateStatus(`Error al enviar JSON: ${sendError.message}`, 'error'); wsStatus = 'error'; updateWebSocketStatusIndicator(); } } else { console.error("Error: El Base64 generado desde canvas oculto no es válido o está vacío."); updateStatus('Error al generar snapshot limpio Base64.', 'error'); } } catch (err) { console.error("Error durante captura/envío de snapshot limpio:", err); updateStatus('Error al procesar snapshot limpio para envío.', 'error'); } }
        // --- Fin WebSocket Functions ---

        // --- Core Functions ---
        async function loadModel() { showLoading('Cargando modelo de detección...'); isModelReady = false; try { await tf.ready(); model = await cocoSsd.load(); console.log("Modelo cargado."); if (!model) throw new Error('Modelo devuelto es null'); isModelReady = true; checkIfReadyToDetect(); } catch (err) { console.error("Error cargando modelo:", err); updateMainStatus(`Error cargando modelo: ${err.message}.`, 'error'); hideLoading(); throw err; } }

        // Modificado: Ya no oculta el loading, solo verifica si iniciar loop
        function checkIfReadyToDetect() {
            if (isModelReady && isVideoPlaying) { // Solo si modelo y video están listos Y reproduciendo
                // hideLoading(); // <-- Eliminado de aquí
                updateStatus(isWsConnected ? 'Detectando...' : 'Listo. Conéctate al servidor WS.', 'info');
                if (isWsConnected) {
                    pauseButton.disabled = false;
                }
                if (!animationFrameId && !isPaused) {
                     detectAndTrackLoop();
                }
            } else {
                 console.log(`CheckIfReady: Modelo=${isModelReady}, VideoPlaying=${isVideoPlaying}. Esperando...`);
                 // Mantiene el estado de loading si alguna condición no se cumple
                 if (!loadingIndicator.classList.contains('d-none') && loadingStatusText.textContent.startsWith('Inicializando')) {
                      // Si aún está el loader inicial, no cambiar mensaje
                 } else if (!isVideoPlaying) {
                     updateMainStatus(`Esperando inicio de vídeo (${currentVideoSource})...`, 'info');
                 } else if (!isModelReady) {
                      updateMainStatus('Esperando carga del modelo...', 'info');
                 }
            }
        }

        function updateCountersUI() { entradasElement.textContent = entradas; salidasElement.textContent = salidas; const personasDentro = Math.max(0, entradas - salidas); personasDentroElement.textContent = personasDentro; }
        function updateDirectionIndicatorUI() { let primaryDir, secondaryDir, primaryClass, secondaryClass; if (isLineHorizontal) { primaryDir = "↑ Arriba"; secondaryDir = "↓ Abajo"; if (isInverted) { primaryDir += " (Entrada)"; secondaryDir += " (Salida)"; primaryClass = "text-success fw-bold"; secondaryClass = "text-danger"; } else { primaryDir += " (Salida)"; secondaryDir += " (Entrada)"; primaryClass = "text-danger"; secondaryClass = "text-success fw-bold"; } } else { primaryDir = "← Izquierda"; secondaryDir = "→ Derecha"; if (isInverted) { primaryDir += " (Salida)"; secondaryDir += " (Entrada)"; primaryClass = "text-danger"; secondaryClass = "text-success fw-bold"; } else { primaryDir += " (Entrada)"; secondaryDir += " (Salida)"; primaryClass = "text-success fw-bold"; secondaryClass = "text-danger"; } } directionPrimarySpan.textContent = primaryDir; directionPrimarySpan.className = primaryClass; directionSecondarySpan.textContent = secondaryDir; directionSecondarySpan.className = secondaryClass; invertButton.classList.toggle('active', isInverted); invertButton.textContent = isInverted ? 'Sentido Invertido' : 'Invertir Sentido'; }
        function applyFlashFeedback() { const counterDisplay = document.getElementById('counter-display'); counterDisplay.classList.remove('flash-success'); void counterDisplay.offsetWidth; counterDisplay.classList.add('flash-success'); }
        function updateTracking(predictions) { const currentDetections = []; predictions.forEach(p => { if (p.class === 'person' && p.score >= scoreThreshold) { currentDetections.push({ bbox: p.bbox, centroid: calculateCentroid(p.bbox), score: p.score }); } }); const matchedIndices = new Set(); const updatedTrackIds = new Set(); let crossedThisFrame = false; trackedPersons.forEach((trackData, trackId) => { let bestMatchIndex = -1; let minDistance = MAX_DISTANCE; for (let i = 0; i < currentDetections.length; i++) { if (!matchedIndices.has(i)) { const dist = calculateDistance(trackData.centroid, currentDetections[i].centroid); if (dist < minDistance) { minDistance = dist; bestMatchIndex = i; } } } if (bestMatchIndex !== -1) { const matchedDetection = currentDetections[bestMatchIndex]; const previousSide = trackData.side; const currentSide = getSide(matchedDetection.centroid); trackData.bbox = matchedDetection.bbox; trackData.centroid = matchedDetection.centroid; trackData.missedFrames = 0; trackData.updated = true; trackData.side = currentSide; updatedTrackIds.add(trackId); matchedIndices.add(bestMatchIndex); if (previousSide && currentSide && previousSide !== currentSide) { const now = Date.now(); if (cooldownMillis === 0 || !trackData.lastCrossTime || (now - trackData.lastCrossTime > cooldownMillis)) { let isEntrada = null; if (isLineHorizontal) { if (previousSide === 'top' && currentSide === 'bottom') isEntrada = !isInverted; else if (previousSide === 'bottom' && currentSide === 'top') isEntrada = isInverted; } else { if (previousSide === 'left' && currentSide === 'right') isEntrada = !isInverted; else if (previousSide === 'right' && currentSide === 'left') isEntrada = isInverted; } if (isEntrada !== null) { let directionString = ''; if (isEntrada) { entradas++; directionString = 'IN'; } else { salidas++; directionString = 'OUT'; } console.log(`Cruce detectado (ID:${trackId}) -> ${directionString}. Enviando snapshot...`); crossedThisFrame = true; trackData.lastCrossTime = now; sendCanvasSnapshotViaWebSocket(directionString); } } } } else { trackData.missedFrames++; trackData.updated = false; } }); trackedPersons.forEach((trackData, trackId) => { if (trackData.missedFrames > MAX_MISSED_FRAMES) { console.log(`Eliminando pista ${trackId} por inactividad.`); trackedPersons.delete(trackId); } }); for (let i = 0; i < currentDetections.length; i++) { if (!matchedIndices.has(i)) { const newDetection = currentDetections[i]; const newTrackId = nextTrackId++; const initialSide = getSide(newDetection.centroid); console.log(`Nueva pista ID: ${newTrackId}`); trackedPersons.set(newTrackId, { id: newTrackId, bbox: newDetection.bbox, centroid: newDetection.centroid, missedFrames: 0, side: initialSide, updated: true, lastCrossTime: null }); } } if (crossedThisFrame) { updateCountersUI(); applyFlashFeedback(); } }
        function drawFrameAndDetections() { if (!canvasCtx || !canvasElement.width || !canvasElement.height || !isModelReady || videoElement.readyState < 3 || !isVideoPlaying) { return; } try { canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height); canvasCtx.save(); canvasCtx.scale(-1, 1); canvasCtx.drawImage(videoElement, -canvasElement.width, 0, canvasElement.width, canvasElement.height); canvasCtx.restore(); canvasCtx.beginPath(); canvasCtx.strokeStyle = 'rgba(220, 53, 69, 0.9)'; canvasCtx.lineWidth = 4; canvasCtx.setLineDash([5, 5]); if (isLineHorizontal && lineaImaginariaY !== null) { canvasCtx.moveTo(0, lineaImaginariaY); canvasCtx.lineTo(canvasElement.width, lineaImaginariaY); } else if (!isLineHorizontal && lineaImaginariaX !== null) { canvasCtx.moveTo(lineaImaginariaX, 0); canvasCtx.lineTo(lineaImaginariaX, canvasElement.height); } canvasCtx.stroke(); canvasCtx.setLineDash([]); canvasCtx.closePath(); const oldTrackIds = canvasContainer.querySelectorAll('.track-id'); oldTrackIds.forEach(el => el.remove()); trackedPersons.forEach((trackData, trackId) => { if(trackData.updated || trackData.missedFrames <= 2) { const [rawX, y, rawWidth, height] = trackData.bbox; const x_inverted = canvasElement.width - rawX - rawWidth; canvasCtx.strokeStyle = trackData.updated ? 'rgba(25, 135, 84, 0.9)' : 'rgba(255, 193, 7, 0.7)'; canvasCtx.lineWidth = 2; canvasCtx.strokeRect(x_inverted, y, rawWidth, height); } }); } catch(e) { console.error("Error dibujando:", e); updateMainStatus('Error al dibujar.', 'warning'); } }
        async function detectAndTrackLoop() { if (!isPaused && isModelReady && isVideoPlaying && model && videoElement.readyState >= 3 && canvasElement.width > 0) { frameCounter++; try { let predictions = []; if (frameCounter % frameSkipCount === 0) { predictions = await model.detect(videoElement); updateTracking(predictions); if (isWsConnected) { updateMainStatus('Detectando...', 'info'); } else if (wsStatus !== 'connecting') { updateMainStatus('Listo. Conéctate al servidor WS.', 'info'); } } drawFrameAndDetections(); } catch(e) { console.error("Error en bucle:", e); updateMainStatus('Error en procesamiento.', 'error'); } } animationFrameId = requestAnimationFrame(detectAndTrackLoop); }

        // --- Event Listeners ---
        // Fuente de vídeo
        sourceWebcamRadio.addEventListener('change', () => { if (sourceWebcamRadio.checked) { hlsUrlContainer.style.display = 'none'; } });
        sourceHLSRadio.addEventListener('change', () => { if (sourceHLSRadio.checked) { hlsUrlContainer.style.display = 'block'; } });
        setSourceButton.addEventListener('click', () => { const selectedSource = document.querySelector('input[name="videoSource"]:checked').value; setSourceButton.disabled = true; setSourceButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Aplicando...'; pauseButton.disabled = true; isPaused = false; updatePauseButton(); if (selectedSource === 'webcam') { setupWebcam().finally(() => { setSourceButton.disabled = false; setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente'; }); } else if (selectedSource === 'hls') { const url = hlsUrlInput.value.trim(); if (url && (url.startsWith('http://') || url.startsWith('https://')) && url.endsWith('.m3u8')) { setupHLS(url); } else { updateMainStatus('URL HLS inválida. Debe ser URL completa .m3u8.', 'warning'); setSourceButton.disabled = false; setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente'; } } });

        // WebSocket
        wsConnectButton.addEventListener('click', () => { if (websocket && websocket.readyState === WebSocket.OPEN) { console.log("Desconectando manualmente..."); websocket.close(); } else { connectWebSocket(); } });
        // Controles Generales
        resetButton.addEventListener('click', () => { console.log('Reseteando contadores y pistas...'); entradas = 0; salidas = 0; trackedPersons.clear(); nextTrackId = 0; updateCountersUI(); const oldTrackIds = canvasContainer.querySelectorAll('.track-id'); oldTrackIds.forEach(el => el.remove()); if (!isPaused) updateStatus(isWsConnected ? 'Contadores reseteados. Detectando...' : 'Contadores reseteados. Conéctate al WS.', 'info'); else updateMainStatus('Contadores reseteados. Pausado.', 'info'); });
        invertButton.addEventListener('click', () => { isInverted = !isInverted; console.log('Sentido invertido:', isInverted); updateDirectionIndicatorUI(); });
        function updatePauseButton() { if (!isWsConnected || !isVideoPlaying || !isModelReady) { pauseButton.disabled = true; pauseButton.innerHTML = '<i class="bi bi-pause-fill"></i> Pausar'; pauseButton.classList.remove('paused'); isPaused = false; return; } if (isPaused) { pauseButton.innerHTML = '<i class="bi bi-play-fill"></i> Reanudar'; pauseButton.classList.add('paused'); updateMainStatus('Pausado.'); console.log("Pausado"); } else { pauseButton.innerHTML = '<i class="bi bi-pause-fill"></i> Pausar'; pauseButton.classList.remove('paused'); updateMainStatus('Detectando...'); console.log("Reanudado"); } pauseButton.disabled = false; }
        pauseButton.addEventListener('click', () => { if (!isWsConnected || !isVideoPlaying || !isModelReady) return; isPaused = !isPaused; updatePauseButton(); });
        lineSlider.addEventListener('input', (event) => { calculateLinePosition(); });
        lineOrientationSwitch.addEventListener('change', (event) => { isLineHorizontal = event.target.checked; console.log(`Orientación -> ${isLineHorizontal ? 'Horizontal' : 'Vertical'}`); calculateLinePosition(); updateDirectionIndicatorUI(); trackedPersons.clear(); nextTrackId = 0; console.log("Pistas reseteadas por cambio de orientación."); if (!isPaused) updateStatus(isWsConnected ? 'Orientación cambiada. Detectando...' : 'Orientación cambiada. Conéctate al WS.', 'info'); else updateMainStatus('Orientación cambiada. Pausado.', 'info'); });
        scoreThresholdSlider.addEventListener('input', (e) => { scoreThreshold = parseFloat(e.target.value); scoreThresholdValueSpan.textContent = `${Math.round(scoreThreshold * 100)}%`; });
        frameSkipSlider.addEventListener('input', (e) => { frameSkipCount = parseInt(e.target.value); frameSkipValueSpan.textContent = `${frameSkipCount} fr.`; });
        cooldownSlider.addEventListener('input', (e) => { cooldownMillis = parseInt(e.target.value); cooldownValueSpan.textContent = `${cooldownMillis}ms`; });

        // Event listener para redimensionar canvas y verificar readiness
        videoElement.addEventListener('loadedmetadata', () => {
            console.log("Metadatos de vídeo cargados.");
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;
            if (videoWidth && videoHeight) {
                 canvasElement.width = videoWidth; canvasElement.height = videoHeight;
                 hiddenCanvasElement.width = videoWidth; hiddenCanvasElement.height = videoHeight;
                 canvasContainer.style.aspectRatio = `${videoWidth} / ${videoHeight}`;
                 calculateLinePosition();
                 console.log(`Canvas redimensionado a ${videoWidth}x${videoHeight}`);
                 if(currentVideoSource === 'webcam') isWebcamReady = true;
                 // No llamamos a checkIfReady todavía, esperamos a 'playing'
            } else {
                console.error("Error: Dimensiones de vídeo inválidas en loadedmetadata.");
                updateMainStatus('Error: Dimensiones de vídeo inválidas.', 'error');
                hideLoading(); // Ocultar si hay error aquí
            }
        });

        // --- NUEVO: Listener para evento 'playing' ---
        videoElement.addEventListener('playing', () => {
            console.log("Evento 'playing' detectado para la fuente de vídeo.");
            isVideoPlaying = true;
            hideLoading(); // <-- Ocultar el loader AQUI
            checkIfReadyToDetect(); // Verificar si ya podemos empezar a detectar
            // Si se cambió a HLS, re-habilitar el botón por si acaso
            if (currentVideoSource === 'hls' && setSourceButton.disabled) {
                 setSourceButton.disabled = false;
                 setSourceButton.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i> Establecer Fuente';
            }
        });

        // --- Inicialización ---
        function initializeUI() { scoreThresholdSlider.value = scoreThreshold; scoreThresholdValueSpan.textContent = `${Math.round(scoreThreshold * 100)}%`; frameSkipSlider.value = frameSkipCount; frameSkipValueSpan.textContent = `${frameSkipCount} fr.`; cooldownSlider.value = cooldownMillis; cooldownValueSpan.textContent = `${cooldownMillis}ms`; lineSlider.value = 50; lineValueSpan.textContent = `${lineSlider.value}%`; lineOrientationSwitch.checked = isLineHorizontal; const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]'); [...popoverTriggerList].map(popoverTriggerEl => new bootstrap.Popover(popoverTriggerEl, { trigger: 'focus hover' })); updateCountersUI(); updateDirectionIndicatorUI(); pauseButton.disabled = true; wsConnectButton.disabled = false; wsConnectButton.innerHTML = '<i class="bi bi-plug-fill me-1"></i> Conectar al Servidor WS'; wsConnectButton.classList.remove('btn-secondary'); wsConnectButton.classList.add('btn-primary'); updateWebSocketStatusIndicator(); updateMainStatus('Inicializando y cargando recursos...', 'info'); hlsUrlContainer.style.display = 'none'; }
        async function main() {
            initializeUI();
            showLoading('Inicializando aplicación...'); // Muestra loading inicial
            try {
                await loadModel(); // Carga el modelo primero
                await setupWebcam(); // Intenta iniciar webcam por defecto
            } catch (error) {
                console.error("Fallo inicialización (modelo o webcam):", error);
                // hideLoading() se llama dentro de los setup o en caso de error
                updateMainStatus('Error en inicialización. Comprueba permisos o selecciona fuente HLS.', 'warning');
            }
        }

        // --- Inicio y Limpieza ---
        window.addEventListener('load', main);
        window.addEventListener('unload', () => { console.log("Descargando página..."); if (animationFrameId) cancelAnimationFrame(animationFrameId); cleanupVideoSource(); if (websocket && websocket.readyState === WebSocket.OPEN) { websocket.close(); console.log("WebSocket cerrado al descargar página."); } });
    </script>
</body>
</html>