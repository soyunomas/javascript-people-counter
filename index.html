<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contador de Personas</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <!-- Optional: Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        body { background-color: #f8f9fa; padding-bottom: 1rem; }
        #webcam { /* Sigue oculto */ }
        #canvas-container {
            position: relative; width: 100%;
            margin-bottom: 0.5rem;
            border: 2px solid #0d6efd; background-color: #fff; overflow: hidden;
            aspect-ratio: 4 / 3; /* Default, se ajustará */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #canvas { display: block; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); -webkit-transform: scaleX(-1); }
        #loading-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 10; background-color: rgba(255, 255, 255, 0.85);
            padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #loading-indicator .spinner-border { width: 3rem; height: 3rem; }
        #loading-status-text { margin-top: 0.8rem; font-weight: 500; color: #495057; }
        .track-id { position: absolute; background-color: rgba(220, 53, 69, 0.8); color: white; padding: 1px 4px; font-size: 10px; border-radius: 3px; white-space: nowrap; pointer-events: none; font-weight: bold; }
        #direction-indicator { font-size: 0.9em; color: #6c757d; }
        #status, #track-count-display { min-height: 1.2em; font-size: 0.85em; }
        #invert-button.active { background-color: #198754; border-color: #198754; }
        #pause-button.paused { background-color: #ffc107; border-color: #ffc107; color: black; }
        @keyframes flash { 0% { background-color: #d1e7dd; } 100% { background-color: transparent; } }
        .flash-success { animation: flash 0.5s ease-out; }
        .form-range { cursor: pointer; }
        .popover-trigger { cursor: help; }
        .input-group-text { min-width: 55px; justify-content: center; font-size: 0.8em; }
        .settings-section label.col-form-label-sm { font-size: 0.9em; }
        .form-switch .form-check-label { font-size: 0.9em; }
        h1.h3 { font-size: 1.5rem; }
        .right-panel { max-height: 90vh; overflow-y: auto; padding: 1rem; }
        .right-panel .alert { font-size: 2.1rem; padding: 0.6rem; }
        .right-panel .alert .fw-bold { font-size: 2.1rem; }
        .right-panel .btn-sm { padding: 0.2rem 0.5rem; font-size: 0.8rem;}
        .right-panel .h6 { font-size: 1rem; }
        .right-panel .form-check-label { font-size: 0.85em;}
        .right-panel .small, .right-panel .form-label { font-size: 0.85em;}
        #status.error { color: #dc3545; font-weight: bold; }
        #status.warning { color: #ffc107; }
    </style>
</head>
<body class="pt-3">

    <div class="container-fluid">
         <h1 class="mb-3 h3 text-center">Contador de Personas</h1>
        <div class="row g-3">
            <!-- Columna Izquierda: Canvas -->
            <div class="col-lg-6 col-md-6 d-flex flex-column align-items-center">
                 <video id="webcam" autoplay muted playsinline class="d-none"></video>
                 <div id="canvas-container">
                    <div id="loading-indicator" class="d-none">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Cargando...</span>
                        </div>
                        <p id="loading-status-text" class="mb-0">Inicializando...</p>
                    </div>
                    <canvas id="canvas"></canvas>
                 </div>
                 <div class="text-center text-muted small w-100 mt-1">
                    <span id="track-count-display" class="me-3">Pistas activas: 0</span>
                    <span id="status">Cargando aplicación...</span>
                 </div>
            </div>

            <!-- Columna Derecha: Controles y Ajustes -->
            <div class="col-lg-6 col-md-6">
                <div class="right-panel">
                    <!-- Sección Principal de Controles -->
                    <div id="controls" class="d-flex flex-column align-items-center gap-2 mb-3 w-100">
                        <div id="counter-display" class="alert alert-success text-center p-2 w-100 mb-1"> Entradas: <span id="entradas" class="fw-bold">0</span> | Salidas: <span id="salidas" class="fw-bold">0</span> </div>
                        <div id="direction-indicator" class="text-center w-100"> <span id="direction-primary" class="text-success fw-bold"></span> | <span id="direction-secondary" class="text-danger"></span> <small class="d-block text-muted">(Cruzando la línea roja)</small> </div>                         <div id="line-slider-container" class="d-flex align-items-center gap-2 w-100 px-1"> <label for="line-position-slider" class="form-label mb-0 small">Pos. Línea:</label> <input type="range" class="form-range flex-grow-1" id="line-position-slider" min="5" max="95" value="50"> <span id="line-position-value" class="badge bg-secondary" style="min-width: 40px;">50%</span> </div>
                        <div class="form-check form-switch align-self-center my-1"> <input class="form-check-input" type="checkbox" role="switch" id="line-orientation-switch"> <label class="form-check-label" for="line-orientation-switch">Línea Horizontal</label> </div>
                        <div id="personas-dentro-display" class="alert alert-info text-center p-2 w-100 mb-2"> Personas Dentro: <span id="personas-dentro" class="fw-bold">0</span> </div>
                        <div class="d-flex gap-2 justify-content-center flex-wrap w-100"> <button id="reset-button" class="btn btn-danger btn-sm">Resetear</button> <button id="invert-button" class="btn btn-warning btn-sm">Invertir Sentido</button> <button id="pause-button" class="btn btn-secondary btn-sm" disabled> <i class="bi bi-pause-fill"></i> Pausar </button> </div>
                    </div>
                    <!-- Sección de Ajustes -->
                    <div id="settings" class="p-3 border rounded bg-light mb-3 w-100 settings-section">
                        <h5 class="mb-3 text-center h6">Ajustes de Detección</h5>
                        <div class="mb-3 row gx-2 align-items-center"> <label for="score-threshold-slider" class="col-sm-4 col-form-label col-form-label-sm">Confianza Mín.:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="score-threshold-slider" min="0.1" max="0.9" step="0.05" value="0.5"> <span class="input-group-text" id="score-threshold-value">50%</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Umbral de Confianza" data-bs-content="Ignora detecciones si la confianza es menor. Filtra detecciones dudosas."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                        <div class="mb-3 row gx-2 align-items-center"> <label for="frame-skip-slider" class="col-sm-4 col-form-label col-form-label-sm">Procesar cada:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="frame-skip-slider" min="1" max="10" step="1" value="1"> <span class="input-group-text" id="frame-skip-value">1 fr.</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Salto de Frames" data-bs-content="Procesa sólo cada N frames. Reduce uso de CPU a costa de reactividad."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                        <div class="mb-2 row gx-2 align-items-center"> <label for="cooldown-slider" class="col-sm-4 col-form-label col-form-label-sm">Cooldown Cruce:</label> <div class="col-sm-8"><div class="input-group input-group-sm"> <input type="range" class="form-range" id="cooldown-slider" min="0" max="5000" step="250" value="1000"> <span class="input-group-text" id="cooldown-value">1000ms</span> <button class="btn btn-outline-secondary popover-trigger btn-sm" type="button" data-bs-toggle="popover" title="Cooldown de Cruce" data-bs-content="Tiempo mínimo (ms) antes de volver a contar a la misma persona. Evita conteo múltiple. 0 deshabilita."><i class="bi bi-question-circle"></i></button> </div></div> </div>
                    </div>
                </div> <!-- Fin .right-panel -->
            </div> <!-- Fin Columna Derecha -->
        </div> <!-- Fin .row -->
    </div> <!-- Fin .container-fluid -->

    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

    <script>
        // --- DOM Elements ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusElement = document.getElementById('status');
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingStatusText = document.getElementById('loading-status-text');
        const entradasElement = document.getElementById('entradas');
        const salidasElement = document.getElementById('salidas');
        const personasDentroElement = document.getElementById('personas-dentro');
        const resetButton = document.getElementById('reset-button');
        const invertButton = document.getElementById('invert-button');
        const pauseButton = document.getElementById('pause-button');
        const canvasContainer = document.getElementById('canvas-container');
        const lineSlider = document.getElementById('line-position-slider');
        const lineValueSpan = document.getElementById('line-position-value');
        const lineOrientationSwitch = document.getElementById('line-orientation-switch');
        const directionPrimarySpan = document.getElementById('direction-primary');
        const directionSecondarySpan = document.getElementById('direction-secondary');
        const trackCountDisplay = document.getElementById('track-count-display');
        const scoreThresholdSlider = document.getElementById('score-threshold-slider');
        const scoreThresholdValueSpan = document.getElementById('score-threshold-value');
        const frameSkipSlider = document.getElementById('frame-skip-slider');
        const frameSkipValueSpan = document.getElementById('frame-skip-value');
        const cooldownSlider = document.getElementById('cooldown-slider');
        const cooldownValueSpan = document.getElementById('cooldown-value');

        // --- State Variables ---
        let model = null;
        let lineaImaginariaX = null; let lineaImaginariaY = null;
        let isLineHorizontal = false;
        let animationFrameId = null;
        let isInverted = false; // Se mantiene en false por defecto
        let isPaused = false; let frameCounter = 0;

        // --- Tracking State ---
        let trackedPersons = new Map();
        let nextTrackId = 0; let entradas = 0; let salidas = 0;

        // --- Configurable Parameters ---
        let scoreThreshold = 0.5; let frameSkipCount = 1; let cooldownMillis = 1000;

        // --- Tracking Parameters ---
        const MAX_DISTANCE = 100; const MAX_MISSED_FRAMES = 10;

        // --- Loader Functions ---
        function showLoading(message) { loadingStatusText.textContent = message; loadingIndicator.classList.remove('d-none'); statusElement.textContent = message; statusElement.classList.remove('error', 'warning'); }
        function hideLoading() { loadingIndicator.classList.add('d-none'); }

        // --- Helper Functions ---
        function calculateCentroid(bbox) { return { x: bbox[0] + bbox[2] / 2, y: bbox[1] + bbox[3] / 2 }; }
        function calculateDistance(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
        function getSide(centroid) {
            const canvasCentroidX = canvasElement.width - centroid.x;
            if (isLineHorizontal) { if (lineaImaginariaY === null) return null; return centroid.y < lineaImaginariaY ? 'top' : 'bottom'; }
            else { if (lineaImaginariaX === null) return null; return canvasCentroidX < lineaImaginariaX ? 'left' : 'right'; }
        }
        function calculateLinePosition() { const sliderValue = parseInt(lineSlider.value); if (isLineHorizontal) { if(canvasElement.height > 0) { lineaImaginariaY = (sliderValue / 100) * canvasElement.height; lineaImaginariaX = null; } } else { if(canvasElement.width > 0) { lineaImaginariaX = (sliderValue / 100) * canvasElement.width; lineaImaginariaY = null; } } lineValueSpan.textContent = `${sliderValue}%`; }
        function updateStatus(message, type = 'info') { statusElement.textContent = message; statusElement.className = ''; if (type === 'error') statusElement.classList.add('error'); else if (type === 'warning') statusElement.classList.add('warning'); }
        function addSecureContextWarning(baseMessage) { return `${baseMessage} (Nota: Usar localhost/HTTPS es lo recomendado y más fiable.)`; }

        // --- Core Functions ---
        async function setupWebcam() {
            showLoading('Solicitando acceso a la webcam...');
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                 updateStatus(addSecureContextWarning('Error: API de Webcam no soportada.'), 'error');
                 throw new Error('getUserMedia no soportado.');
             }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                videoElement.srcObject = stream;
                videoElement.muted = true;

                return new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = () => {
                        console.log("Metadatos de webcam cargados.");
                        showLoading('Webcam lista, ajustando...');
                        const videoWidth = videoElement.videoWidth; const videoHeight = videoElement.videoHeight;
                        if (!videoWidth || !videoHeight) { console.error("Dimensiones inválidas:", videoWidth, videoHeight); updateStatus('Error: Dimensiones webcam inválidas.', 'error'); reject(new Error('Dimensiones inválidas')); return; }
                        canvasElement.width = videoWidth; canvasElement.height = videoHeight;
                        canvasContainer.style.aspectRatio = `${videoWidth} / ${videoHeight}`;
                        isLineHorizontal = lineOrientationSwitch.checked;
                        calculateLinePosition();
                        console.log(`Dimensiones Canvas/Video: ${videoWidth}x${videoHeight}`);

                        videoElement.play()
                            .then(() => {
                                console.log("Video principal reproduciendo.");
                                resolve();
                            })
                            .catch(err => {
                                console.error("Error al reproducir video principal:", err);
                                updateStatus('Error al iniciar reproducción de video.', 'warning');
                                resolve();
                            });
                    };
                    videoElement.onerror = (e) => { console.error("Error en video principal:", e); updateStatus('Error interno video principal.', 'error'); reject(new Error('Error video principal')); }
                });
            } catch (err) {
                console.error("Error al acceder webcam:", err.name, err.message);
                let userMessage = 'Error al acceder a la webcam.';
                 if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = 'Permiso denegado para la webcam.';
                 else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = 'No se encontró cámara web.';
                 else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') userMessage = 'Cámara ocupada o error hardware.';
                 else if (err.name === 'SecurityError') userMessage = addSecureContextWarning('Error seguridad cámara.');
                 else userMessage = `Error desconocido (${err.name}).`;
                 updateStatus(addSecureContextWarning(userMessage), 'error');
                throw err;
            }
        }
        async function loadModel() {
             showLoading('Cargando modelo de detección...');
             try { await tf.ready(); model = await cocoSsd.load(); console.log("Modelo cargado."); if (!model) throw new Error('Modelo devuelto es null'); }
             catch (err) { console.error("Error cargando modelo:", err); updateStatus(`Error cargando modelo: ${err.message}.`, 'error'); throw err; }
        }
        function updateCountersUI() { entradasElement.textContent = entradas; salidasElement.textContent = salidas; const personasDentro = Math.max(0, entradas - salidas); personasDentroElement.textContent = personasDentro; }

        // --- MODIFICACIÓN AQUÍ ---
        function updateDirectionIndicatorUI() {
            let primaryDir, secondaryDir, primaryClass, secondaryClass;

            if (isLineHorizontal) {
                primaryDir = "↑ Arriba";
                secondaryDir = "↓ Abajo";
                // La lógica para línea horizontal no se solicitó cambiar, se mantiene como estaba:
                if (isInverted) { // Si está invertido, Arriba es Entrada (Verde), Abajo es Salida (Rojo)
                    primaryDir += " (Entrada)"; secondaryDir += " (Salida)";
                    primaryClass = "text-success fw-bold"; secondaryClass = "text-danger";
                } else { // Si NO está invertido, Arriba es Salida (Rojo), Abajo es Entrada (Verde)
                    primaryDir += " (Salida)"; secondaryDir += " (Entrada)";
                    primaryClass = "text-danger"; secondaryClass = "text-success fw-bold";
                }
            } else { // Línea Vertical (!isLineHorizontal)
                primaryDir = "← Izquierda";
                secondaryDir = "→ Derecha";
                // Se ajusta la lógica aquí para que coincida con la observación del usuario
                if (isInverted) { // Si está invertido, Izquierda es Salida (Rojo), Derecha es Entrada (Verde)
                    primaryDir += " (Salida)"; secondaryDir += " (Entrada)";
                    primaryClass = "text-danger"; secondaryClass = "text-success fw-bold";
                } else { // Si NO está invertido, Izquierda es Entrada (Verde), Derecha es Salida (Rojo) << CAMBIO REALIZADO
                    primaryDir += " (Entrada)"; secondaryDir += " (Salida)";
                    primaryClass = "text-success fw-bold"; secondaryClass = "text-danger";
                }
            }

            directionPrimarySpan.textContent = primaryDir;
            directionPrimarySpan.className = primaryClass; // Asegura que la clase se aplique
            directionSecondarySpan.textContent = secondaryDir;
            directionSecondarySpan.className = secondaryClass; // Asegura que la clase se aplique

            // Actualizar estado visual del botón invertir
            invertButton.classList.toggle('active', isInverted);
            invertButton.textContent = isInverted ? 'Sentido Invertido' : 'Invertir Sentido';
        }
        // --- FIN DE MODIFICACIÓN ---

        function applyFlashFeedback() { const counterDisplay = document.getElementById('counter-display'); counterDisplay.classList.remove('flash-success'); void counterDisplay.offsetWidth; counterDisplay.classList.add('flash-success'); }
        function updateTracking(predictions) { const currentDetections = []; predictions.forEach(p => { if (p.class === 'person' && p.score >= scoreThreshold) { currentDetections.push({ bbox: p.bbox, centroid: calculateCentroid(p.bbox), score: p.score }); } }); const matchedIndices = new Set(); const updatedTrackIds = new Set(); let crossedThisFrame = false; trackedPersons.forEach((trackData, trackId) => { let bestMatchIndex = -1; let minDistance = MAX_DISTANCE; for (let i = 0; i < currentDetections.length; i++) { if (!matchedIndices.has(i)) { const dist = calculateDistance(trackData.centroid, currentDetections[i].centroid); if (dist < minDistance) { minDistance = dist; bestMatchIndex = i; } } } if (bestMatchIndex !== -1) { const matchedDetection = currentDetections[bestMatchIndex]; const previousSide = trackData.side; const currentSide = getSide(matchedDetection.centroid); trackData.bbox = matchedDetection.bbox; trackData.centroid = matchedDetection.centroid; trackData.missedFrames = 0; trackData.updated = true; trackData.side = currentSide; updatedTrackIds.add(trackId); matchedIndices.add(bestMatchIndex); if (previousSide && currentSide && previousSide !== currentSide) { const now = Date.now(); if (cooldownMillis === 0 || !trackData.lastCrossTime || (now - trackData.lastCrossTime > cooldownMillis)) { let isEntrada = null; if (isLineHorizontal) { if (previousSide === 'top' && currentSide === 'bottom') isEntrada = !isInverted; else if (previousSide === 'bottom' && currentSide === 'top') isEntrada = isInverted; } else { // Lógica de conteo para línea vertical (NO SE CAMBIA)
                            if (previousSide === 'left' && currentSide === 'right') isEntrada = !isInverted; // Derecha por defecto es Entrada? No, según el usuario es Salida. Pero no cambio lógica.
                            else if (previousSide === 'right' && currentSide === 'left') isEntrada = isInverted; // Izquierda por defecto es Salida? No, según el usuario es Entrada. Pero no cambio lógica.
                         } if (isEntrada !== null) { if (isEntrada) entradas++; else salidas++; console.log(`Cruce (ID:${trackId}) -> ${isEntrada ? 'Entrada' : 'Salida'}`); crossedThisFrame = true; trackData.lastCrossTime = now; } } } } else { trackData.missedFrames++; trackData.updated = false; } }); trackedPersons.forEach((trackData, trackId) => { if (trackData.missedFrames > MAX_MISSED_FRAMES) { console.log(`Eliminando pista ${trackId}`); trackedPersons.delete(trackId); } }); for (let i = 0; i < currentDetections.length; i++) { if (!matchedIndices.has(i)) { const newDetection = currentDetections[i]; const newTrackId = nextTrackId++; const initialSide = getSide(newDetection.centroid); console.log(`Nueva pista ID: ${newTrackId}`); trackedPersons.set(newTrackId, { id: newTrackId, bbox: newDetection.bbox, centroid: newDetection.centroid, missedFrames: 0, side: initialSide, updated: true, lastCrossTime: null }); } } if (crossedThisFrame) { updateCountersUI(); applyFlashFeedback(); } }
        function drawFrameAndDetections() { if (isPaused || !canvasCtx || !canvasElement.width || !canvasElement.height || videoElement.readyState < 3) { return; } try { canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                 canvasCtx.save();
                 canvasCtx.scale(-1, 1);
                 canvasCtx.drawImage(videoElement, -canvasElement.width, 0, canvasElement.width, canvasElement.height);
                 canvasCtx.restore();

                 canvasCtx.beginPath(); canvasCtx.strokeStyle = 'rgba(220, 53, 69, 0.9)'; canvasCtx.lineWidth = 4; canvasCtx.setLineDash([5, 5]); if (isLineHorizontal && lineaImaginariaY !== null) { canvasCtx.moveTo(0, lineaImaginariaY); canvasCtx.lineTo(canvasElement.width, lineaImaginariaY); } else if (!isLineHorizontal && lineaImaginariaX !== null) { canvasCtx.moveTo(lineaImaginariaX, 0); canvasCtx.lineTo(lineaImaginariaX, canvasElement.height); } canvasCtx.stroke(); canvasCtx.setLineDash([]); canvasCtx.closePath();

                 const oldTrackIds = canvasContainer.querySelectorAll('.track-id'); oldTrackIds.forEach(el => el.remove()); trackedPersons.forEach((trackData, trackId) => { if(trackData.updated || trackData.missedFrames <= 2) { const [rawX, y, rawWidth, height] = trackData.bbox;
                         const x = canvasElement.width - rawX - rawWidth;
                         canvasCtx.strokeStyle = trackData.updated ? 'rgba(25, 135, 84, 0.9)' : 'rgba(255, 193, 7, 0.7)'; canvasCtx.lineWidth = 2; canvasCtx.strokeRect(x, y, rawWidth, height);
                         const idElement = document.createElement('div'); idElement.innerText = `ID: ${trackId}`; idElement.classList.add('track-id');
                         const displayX = Math.max(2, Math.min(x + 2, canvasElement.width - 35)); const displayY = Math.max(2, Math.min(y + 2, canvasElement.height - 15)); idElement.style.left = `${displayX}px`; idElement.style.top = `${displayY}px`; if (!trackData.updated) idElement.style.backgroundColor = 'rgba(255, 193, 7, 0.7)'; canvasContainer.appendChild(idElement); } }); trackCountDisplay.textContent = `Pistas activas: ${trackedPersons.size}`; } catch(e) { console.error("Error dibujando:", e); updateStatus('Error al dibujar.', 'warning'); } }
        async function detectAndTrackLoop() { if (isPaused || !model || videoElement.paused || videoElement.ended || videoElement.readyState < 3 || !canvasElement.width) { animationFrameId = requestAnimationFrame(detectAndTrackLoop); return; } frameCounter++; try { let predictions = []; if (frameCounter % frameSkipCount === 0) { const startTime = performance.now(); predictions = await model.detect(videoElement); updateTracking(predictions); statusElement.textContent = 'Detectando...'; statusElement.classList.remove('error', 'warning'); } drawFrameAndDetections(); } catch(e) { console.error("Error en bucle:", e); updateStatus('Error en procesamiento.', 'error'); } animationFrameId = requestAnimationFrame(detectAndTrackLoop); }

        // --- Event Listeners ---
        resetButton.addEventListener('click', () => { console.log('Reseteando...'); entradas = 0; salidas = 0; trackedPersons.clear(); nextTrackId = 0; updateCountersUI(); const oldTrackIds = canvasContainer.querySelectorAll('.track-id'); oldTrackIds.forEach(el => el.remove()); trackCountDisplay.textContent = `Pistas activas: 0`; if (!isPaused) updateStatus('Contadores reseteados. Detectando...', 'info'); else updateStatus('Contadores reseteados. Pausado.', 'info'); });
        invertButton.addEventListener('click', () => { isInverted = !isInverted; console.log('Sentido invertido:', isInverted); updateDirectionIndicatorUI(); }); // Llama a la función modificada
        function updatePauseButton() { if (isPaused) { pauseButton.innerHTML = '<i class="bi bi-play-fill"></i> Reanudar'; pauseButton.classList.add('paused'); statusElement.textContent = 'Pausado.'; statusElement.classList.remove('error'); console.log("Pausado"); if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } } else { pauseButton.innerHTML = '<i class="bi bi-pause-fill"></i> Pausar'; pauseButton.classList.remove('paused'); statusElement.textContent = 'Detectando...'; console.log("Reanudado"); if (animationFrameId === null) detectAndTrackLoop(); } }
        pauseButton.addEventListener('click', () => { isPaused = !isPaused; updatePauseButton(); });
        lineSlider.addEventListener('input', (event) => { calculateLinePosition(); });
        lineOrientationSwitch.addEventListener('change', (event) => { isLineHorizontal = event.target.checked; console.log(`Orientación -> ${isLineHorizontal ? 'Horizontal' : 'Vertical'}`); calculateLinePosition(); updateDirectionIndicatorUI(); // Llama a la función modificada
                 trackedPersons.clear(); nextTrackId = 0; console.log("Pistas reseteadas."); if (!isPaused) updateStatus('Orientación cambiada. Detectando...', 'info'); else updateStatus('Orientación cambiada. Pausado.', 'info'); });
        scoreThresholdSlider.addEventListener('input', (e) => { scoreThreshold = parseFloat(e.target.value); scoreThresholdValueSpan.textContent = `${Math.round(scoreThreshold * 100)}%`; });
        frameSkipSlider.addEventListener('input', (e) => { frameSkipCount = parseInt(e.target.value); frameSkipValueSpan.textContent = `${frameSkipCount} fr.`; });
        cooldownSlider.addEventListener('input', (e) => { cooldownMillis = parseInt(e.target.value); cooldownValueSpan.textContent = `${cooldownMillis}ms`; });

        // --- Inicialización ---
        function initializeUI() { scoreThresholdSlider.value = scoreThreshold; scoreThresholdValueSpan.textContent = `${Math.round(scoreThreshold * 100)}%`; frameSkipSlider.value = frameSkipCount; frameSkipValueSpan.textContent = `${frameSkipCount} fr.`; cooldownSlider.value = cooldownMillis; cooldownValueSpan.textContent = `${cooldownMillis}ms`; lineSlider.value = 50; lineValueSpan.textContent = `${lineSlider.value}%`; lineOrientationSwitch.checked = isLineHorizontal; const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]'); [...popoverTriggerList].map(popoverTriggerEl => new bootstrap.Popover(popoverTriggerEl, { trigger: 'focus hover' })); updateCountersUI(); updateDirectionIndicatorUI(); // Llama a la función modificada al inicio
                 pauseButton.disabled = true; }
        async function main() { initializeUI(); showLoading('Inicializando aplicación...'); try { await loadModel(); await setupWebcam(); hideLoading(); updateStatus('¡Listo! Esperando movimiento...', 'info'); pauseButton.disabled = false; detectAndTrackLoop(); } catch (error) { console.error("Fallo inicialización:", error); hideLoading(); pauseButton.disabled = true; } }

        // --- Inicio y Limpieza ---
        window.addEventListener('load', main);
        window.addEventListener('unload', () => {
            console.log("Descargando página...");
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            const stopTrack = (track) => track.stop();
            if (videoElement && videoElement.srcObject) { videoElement.srcObject.getTracks().forEach(stopTrack); videoElement.srcObject = null; console.log("Webcam principal detenida."); }
        });
    </script>
</body>
</html>
